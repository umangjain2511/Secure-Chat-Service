/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.

 */
package chatserver;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.ServerSocket;
import java.net.Socket;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.util.Arrays;
import java.util.Base64;
import java.util.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import static javax.swing.JOptionPane.showMessageDialog;


public class ChatServer extends javax.swing.JFrame {

    static ServerSocket ss;                     // 6032 for message transfer
    static Socket s;       
    static ServerSocket ssFile;                 // 6033 for file transfer
    static Socket sFile;                        
    static ServerSocket ssPublic;               // 6034 for obtaining public key  
    static Socket sPublic;            
    static ServerSocket ssResponse;
    static Socket sResponse;         
    static ServerSocket ssChall;                // 6036 for  challenge transfer
    static Socket sChall;
    static ServerSocket ssSign;
    static Socket sSign;
    static ServerSocket ssEFile;
    static Socket sEFile;
    
    static Socket sDFile;
    
    static DataInputStream mis;
    static DataOutputStream mos;
    static DataInputStream fis;
    static DataOutputStream fos;
    static DataInputStream cis;
    static DataOutputStream cos;
    static DataInputStream dis2;
    static DataOutputStream dos2;

    static File file;
    
    static String keyAES = "";
    static String serverChall;
    static String clientChall;
    static String strSwitchOffSecure = "Server Discontinues Security. Please disable security by clicking secure button";
    static String fileName;
    static final String charList = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    
    static int btnSelect;
    
    static KeyPair pair;

    static PublicKey clientPublicKey;
    
    static SecureRandom rnd = new SecureRandom();

    
    public ChatServer() throws Exception {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jCheckBox1 = new javax.swing.JCheckBox();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        msgText = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        msgArea = new javax.swing.JTextArea();
        btnSend = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        textAreaSecure = new javax.swing.JTextArea();
        btnAttachFile = new javax.swing.JButton();
        btnSendFile = new javax.swing.JButton();
        btnDownloadFile = new javax.swing.JButton();
        btnSecure = new javax.swing.JToggleButton();
        connectionStatusIcon = new javax.swing.JLabel();
        ConnectionStatusTextField = new javax.swing.JTextField();
        btnAllowProtocol = new javax.swing.JToggleButton();
        jLabel1 = new javax.swing.JLabel();

        jCheckBox1.setText("jCheckBox1");

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane3.setViewportView(jTextArea1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));

        msgText.setColumns(20);
        msgText.setRows(5);
        jScrollPane1.setViewportView(msgText);

        msgArea.setEditable(false);
        msgArea.setColumns(20);
        msgArea.setRows(5);
        jScrollPane2.setViewportView(msgArea);

        btnSend.setText("Send");
        btnSend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendActionPerformed(evt);
            }
        });

        textAreaSecure.setColumns(20);
        textAreaSecure.setLineWrap(true);
        textAreaSecure.setRows(5);
        textAreaSecure.setText("Security is Disabled by Default.\n");
        textAreaSecure.setToolTipText("");
        textAreaSecure.setWrapStyleWord(true);
        textAreaSecure.setAutoscrolls(false);
        jScrollPane4.setViewportView(textAreaSecure);

        btnAttachFile.setText("Attach");
        btnAttachFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAttachFileActionPerformed(evt);
            }
        });

        btnSendFile.setText("send file");
        btnSendFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendFileActionPerformed(evt);
            }
        });

        btnDownloadFile.setText("Download file");
        btnDownloadFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownloadFileActionPerformed(evt);
            }
        });

        btnSecure.setText("Secure : NO");
        btnSecure.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSecureActionPerformed(evt);
            }
        });

        connectionStatusIcon.setBackground(new java.awt.Color(255, 255, 255));
        connectionStatusIcon.setIcon(new javax.swing.ImageIcon(getClass().getResource("/chatserver/noconnection.png"))); // NOI18N
        connectionStatusIcon.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                connectionStatusIconPropertyChange(evt);
            }
        });

        ConnectionStatusTextField.setEditable(false);
        ConnectionStatusTextField.setBackground(new java.awt.Color(255, 255, 255));
        ConnectionStatusTextField.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        ConnectionStatusTextField.setText("\"B\" Connection Status :");
        ConnectionStatusTextField.setBorder(null);
        ConnectionStatusTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ConnectionStatusTextFieldActionPerformed(evt);
            }
        });

        btnAllowProtocol.setText("Allow");
        btnAllowProtocol.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAllowProtocolActionPerformed(evt);
            }
        });

        jLabel1.setFont(jLabel1.getFont().deriveFont(jLabel1.getFont().getStyle() | java.awt.Font.BOLD, 30));
        jLabel1.setText("A");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 371, Short.MAX_VALUE)
                            .addComponent(jScrollPane1))
                        .addGap(18, 18, 18))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(119, 119, 119)))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(0, 19, Short.MAX_VALUE)
                        .addComponent(ConnectionStatusTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(connectionStatusIcon)
                        .addGap(19, 19, 19))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 212, Short.MAX_VALUE)
                            .addComponent(btnSend, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnDownloadFile, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(btnSecure, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnAttachFile, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(btnAllowProtocol, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(btnSendFile, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(ConnectionStatusTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(connectionStatusIcon)))
                .addGap(17, 17, 17)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 115, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(btnSecure, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnAllowProtocol, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnAttachFile, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnSendFile, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(btnDownloadFile, javax.swing.GroupLayout.DEFAULT_SIZE, 53, Short.MAX_VALUE))
                    .addComponent(jScrollPane2))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(btnSend, javax.swing.GroupLayout.DEFAULT_SIZE, 68, Short.MAX_VALUE))
                .addContainerGap())
        );

        btnAllowProtocol.setVisible(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnSendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendActionPerformed
        String msgOut = "";
        try{
            msgOut = msgText.getText().trim();
            mos = new DataOutputStream(s.getOutputStream());
            if(btnSelect==1)
            {
                System.out.println("the encypted message sent is :"+encryptAES("Server : "+msgOut));
                mos.writeUTF(encryptAES("Server : "+msgOut));
            }
            else
                mos.writeUTF("Server : "+msgOut);
                msgArea.setText(msgArea.getText().trim()+"\n"+"me :"+msgOut);
                msgText.setText("");
        }catch(IOException e)
        {
                showMessageDialog(null,"IO Error");
        }catch (Exception ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnSendActionPerformed

    private void btnAttachFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAttachFileActionPerformed
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.showOpenDialog(null);
        file = fileChooser.getSelectedFile();
        fileName =file.getName();
        btnAttachFile.setText(fileName);
    }//GEN-LAST:event_btnAttachFileActionPerformed

    private void btnSendFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendFileActionPerformed
        try {
            if(btnAttachFile.getText().equals("Attach"))
            {
                msgArea.setText(msgArea.getText().trim()+"\n Please attach a file to send");
                return;
            }
            else    
            {
                if(btnSecure.isSelected())
                {
                                    mos.writeUTF(encryptAES("File received, Click Download - FILENAME: " + file.getName()));
                    sDFile = new Socket("127.0.0.1",6039);
                    int fileSize = (int) file.length();
                    byte[] fileByteArray = new byte[(int) file.length()];
                    DataOutputStream fos = new DataOutputStream(sDFile.getOutputStream());
                    fos.writeInt(fileSize);
                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
                    bis.read(fileByteArray, 0, fileByteArray.length);
                    byte[] raw = Base64.getDecoder().decode(keyAES.getBytes());
                    SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
            // make cipher with key
                    Cipher c = Cipher.getInstance("AES");//cipher is going to obtain the instance of the AES algorithm
                    c.init(Cipher.ENCRYPT_MODE, skeySpec);//initializes the cipher to DECRYPT_MODE with the key created            
            // The output stream os is made equal to the output stream of socket s4.
                    OutputStream os = sDFile.getOutputStream();
                    CipherOutputStream cos = new CipherOutputStream(os, c);
            
            // writes bytes of size myBythArray.length (the size of the user specified file) 
            // from myBythArray starting at 0 to output stream os.
                    cos.write(fileByteArray, 0, fileByteArray.length);
                    
                    System.out.println("File Encrypted and sent");
                    cos.flush(); // forces any buffered output bytes to be written out.
                    cos.close();//close cipher output stream
                    msgArea.setText(msgArea.getText().trim()+"\n File Sent - FILENAME: " + file.getName());
                    btnAttachFile.setText("Attach");
                    
                }
                else
                {
                    mos.writeUTF("File Received. Click Download - FILENAME: " + file.getName());
                    int fileSize = (int) file.length();//Obtain the file length and assign it to file size
                    byte[] fileByteArray = new byte[(int) file.length()];//Initialise a byte array for file
                    fos.writeInt(fileSize);
                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));//Obtain the file through fileinputstream
                    bis.read(fileByteArray, 0, fileByteArray.length);//Read the file
                    OutputStream os = sFile.getOutputStream();
                    os.write(fileByteArray, 0, fileByteArray.length);//Write the file onto  output stream
                    msgArea.setText(msgArea.getText().trim()+"\n File Sent");
                    os.flush();
                    btnAttachFile.setText("Attach");
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }//GEN-LAST:event_btnSendFileActionPerformed

    private void btnDownloadFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownloadFileActionPerformed
        try{  

            if(btnSecure.isSelected())
            {
                sEFile = ssEFile.accept();
                JFileChooser chooser = new JFileChooser(); // create object of JFileChooser
                chooser.showSaveDialog(null); // choose save location
                file = chooser.getSelectedFile(); // assign the file equal to f
                DataInputStream efis = new DataInputStream(sEFile.getInputStream());
                int fileLength = efis.readInt(); // read length of incoming file

                //  Create a byte array myByteArray while setting it to the value of filesize
                byte[] myByteArray = new byte[fileLength];
                byte[] raw = Base64.getDecoder().decode(keyAES.getBytes());
                SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
                Cipher cipher = Cipher.getInstance("AES");//cipher is going to obtain the instance of the AES algorithm
                cipher.init(Cipher.DECRYPT_MODE, skeySpec);//initializes the cipher to DECRYPT_MODE with the key created                
                // Create file output stream fos to write to the file specified by f
                FileOutputStream fops = new FileOutputStream(file);

                //creates the Cipher output stream and passes the cipher and the
                //file output stream that writes the file specified by f through it
                CipherOutputStream cos = new CipherOutputStream(fops,cipher);

                // Reads bytes from the input stream din4 and stores them into buffer myByteArray

                byte[] buffer = new byte[8192]; // any size greater than 0 will work
                int count;
                DataInputStream fis2 = new DataInputStream(sEFile.getInputStream());
                while ((count = fis2.read(buffer)) > 0)
                {
                    cos.write(buffer, 0, count);
                }
                    System.out.println("File Decrypted and Downloaded");

                fops.flush();//forces any buffered output bytes to be written out

                cos.close();//closes the cipher outputStream
            }
            else    
            {
                JFileChooser chooser = new JFileChooser();// create object of JFileChooser
                chooser.showSaveDialog(null);// choose save location
                file = chooser.getSelectedFile();// assign the file equal to file
                DataInputStream fis = new DataInputStream(sFile.getInputStream());
                int fileSize = fis.readInt();//read the file size
                byte[] myByteArray = new byte[fileSize];//  Create a byte array myByteArray while setting it to the value of filesize
                //Create a input stream to read the incoming files
                fis.readFully(myByteArray);
                try ( //Create a output stream to write the file
                        FileOutputStream fileOS = new FileOutputStream(file)) {
                        fileOS.write(myByteArray);
                        fileOS.close();
            //close the filesoutput stream
                }
            }
        }catch(Exception e)
        {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, e);
        }
            
        
    }//GEN-LAST:event_btnDownloadFileActionPerformed

    private void btnSecureActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSecureActionPerformed
        try {
            if(btnSecure.isSelected())
            {
                btnSelect=1;
                btnSecure.setText("Secure : ON");
                textAreaSecure.setText("Security is being enabled");
                
                //Step 1 of protocol
                
                //Part A of Step 1 - Send encrypted server challenge to client
                
                //encrypt the challenge with clients public key
                String encryptedServerChall = encryptRSA(serverChall,clientPublicKey);
                //create stream to send to client
                DataOutputStream sendServerChallenge = new DataOutputStream(sChall.getOutputStream());
                //write the encrypted server challenge to stream
                
                System.out.println("Server Challenge : "+serverChall);
                System.out.println("encrypted Server Challenge : "+encryptedServerChall);
                System.out.println("Sending the Encrypted Server Challenge");
                sendServerChallenge.writeUTF(encryptedServerChall);
                
                //part A complete
                
                //Part B of Step 1 - Send the digitally signed hash of server challenge encrypted with clients public key 
                //Create the hash of server challenge
                String I = hash(serverChall);
                //Digitally sign the server challenge with server's private key
                String DS = signRSA(I,pair.getPrivate());
                //Encrypt the Dgitally signed hashed challenge with clients public key
//                String encryptedServerSignature = encryptRSA(DS, clientPublicKey);
                //Create stream to send to client
                DataOutputStream sendSignature = new DataOutputStream(sSign.getOutputStream());
                //write the encrypted signature of the hashed challenge
                System.out.println("Sendng the encrypted digitally signed hashed chall A to client");
                sendSignature.writeUTF(DS);
                System.out.println("Step Completed");
                //part B complete
                
                //Step 1 complete
                
                //Send a prompt to server to accept protocol connection
                DataOutputStream sendAcceptProtocol = new DataOutputStream(s.getOutputStream());
                sendAcceptProtocol.writeUTF("Server Requested Secure Channel. Please click allow");
                

                //Step 4 of Protocol
                
                //Retrieve and assign encrypted client challenge
                DataInputStream receiveClientChall = new DataInputStream(sChall.getInputStream());
                String encryptedClientChall = receiveClientChall.readUTF();
                //decrypt and assign encrypted client challenge
                clientChall = decryptRSA(encryptedClientChall,pair.getPrivate());
                System.out.println("Encrypted client chall is :"+encryptedClientChall);
                System.out.println("Decryptng client chall");
                System.out.println("The decrypted client Chhallenge :"+clientChall);
                
                
                //REMEMBER TO ADD RESPONSE CHECK FOR AES SESSION KEY
                
                
                //Retrieve and store the enrcypted Response from the client
                DataInputStream receiveResponse = new DataInputStream(sResponse.getInputStream());
                String encryptedClientResponse = receiveResponse.readUTF();
                //Decrypt and store the decrypted client response
                String clientResponse = decryptRSA(encryptedClientResponse,pair.getPrivate());
                //Retrieve and assign signature from stream
                DataInputStream receiveSignature = new DataInputStream(sSign.getInputStream());
                String encryptedSignature = receiveSignature.readUTF();
                //decrypt and assign encrypted signature
//                String decryptedSignature = decryptRSA(encryptedSignature,pair.getPrivate());
                //hash the client challenege and response
                System.out.println("decrypt response from client");
                String clientChallRespVerify = hash(clientChall+clientResponse);
                if(verifyRSA(clientChallRespVerify,encryptedSignature, clientPublicKey))
                {
                    System.out.println("response Verified|");
                    String hash1 = hash(serverChall+clientChall);
                    byte[] test = hash1.getBytes(UTF_8);
                    byte[] test1 = Arrays.copyOfRange(test,0,16);
                    String key = Base64.getEncoder().encodeToString(test1);
                    keyAES = key;
                      System.out.println("Session key : "+keyAES);
                      System.out.println("session key is saved");
                      System.out.println("\n\n");
//                    byte[] key = (serverChall+clientChall).getBytes(UTF_8);
//                    MessageDigest sha = MessageDigest.getInstance("SHA-1");
//                    key = sha.digest(key);
//                    System.out.println(key.length);
//                    key = Arrays.copyOf(key, 16); // use only first 128 bit
//                    keyAES = new SecretKeySpec(key, "AES");
//                    System.out.println(Base64.getEncoder().encodeToString(keyAES.getEncoded()));
                      
//                    //Verification Successful
//                    //Convert the hash of challenge and response into byte array
//                    byte[] decodedKey = Base64.getDecoder().decode(hash(serverChall+clientChall));
//                    //feed the byte array to SecretKeySpec object to create the AES session key 
//                    //creates a 128 bit session key by trimming the hash of server and client challenge.
//                    keyAES = new SecretKeySpec(decodedKey,0,16,"AES");
                }
                else
                    throw new Exception("Verification failed");
                //Step 4 Complete
                
                //Step 5 of protocol
                
                //Send response to client
                DataOutputStream sendServerResponse = new DataOutputStream(sResponse.getOutputStream());
                sendServerResponse.writeUTF(encryptAES(clientChall));

            }
            else
            {
                btnSelect=0;
                btnSecure.setText("Secure : OFF");
                DataOutputStream stopSecure = new DataOutputStream(s.getOutputStream());
                stopSecure.writeUTF(encryptAES(strSwitchOffSecure));
                textAreaSecure.setText("Security has been disabled.");
            }
        } catch (Exception ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnSecureActionPerformed

    private void connectionStatusIconPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_connectionStatusIconPropertyChange
        // TODO add your handling code here:
    }//GEN-LAST:event_connectionStatusIconPropertyChange

    private void btnAllowProtocolActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAllowProtocolActionPerformed
try{
            //Step 2 of Protocol initiated by Client
            btnSelect=1;
            //Retreive and assign client Challenge from stream
            DataInputStream receiveClientChallenge = new DataInputStream(sChall.getInputStream());
            String encryptedClientChall = receiveClientChallenge.readUTF();
            //Decrypt encrypted client Challenge with server private key
            clientChall = decryptRSA(encryptedClientChall,pair.getPrivate());

            //Retreive and assign signature from stream
            DataInputStream receiveClientSignature = new DataInputStream(sSign.getInputStream());
            String encryptedClientSignature = receiveClientSignature.readUTF();
            //Decrypt encrypted hashed server challenge signature with servers private key
//            String decryptedServerSignature = decryptRSA(encryptedServerSignature,pair.getPrivate());
            //hash the previously obtained plain client  challenge
            String clientChallVerify = hash(clientChall);
            //Verify the signature using hashed plain server challenge
            if(verifyRSA(clientChallVerify,encryptedClientSignature,clientPublicKey))
            {
                String hash1 = hash(serverChall+clientChall);
                byte[] test = hash1.getBytes(UTF_8);
                byte[] test1 = Arrays.copyOfRange(test,0,16);
                String key = Base64.getEncoder().encodeToString(test1);
                keyAES = key;
                String encrypted = encryptAES("mypassword");
                System.out.println("decrypted value:" + decryptAES(encrypted));
                System.out.println("AES key : "+keyAES);
            }
            else
                throw new Exception("Verification failed");
            //Step 2 complete
            
            //Step 3 begins
            
            //part a - Send encrypted client challenge
            //Encrypt server Challenge
            String encryptedServerChall = encryptRSA(serverChall,clientPublicKey);
            //create stream to send to client
            DataOutputStream sendServerChall = new DataOutputStream(sChall.getOutputStream());
            //write encrypted client challenge into stream
            sendServerChall.writeUTF(encryptedServerChall);
            
            //part b - send client challenge encrypted first with session key and then with clients public key
            //encrypt with session key and assign server challenge
            String encryptedAESClientChall = encryptAES(clientChall);
            //encrypt aes encrypted client challenge with the clients public key
            String encryptedResponse = encryptRSA(encryptedAESClientChall,clientPublicKey);
            //create stream to send to client
            DataOutputStream sendResponse = new DataOutputStream(sResponse.getOutputStream());
            //write the encrypted response to the stream
            sendResponse.writeUTF(encryptedResponse);
            //part c - send signed hash of challenge and response encrypted by server public key
            //Hash the challenge and response
            String I = hash(serverChall+encryptedAESClientChall);

            //sign the hash of challenge and response
            String DS = signRSA(I,pair.getPrivate());
            //encrypt the signature with clients public key
//            String encryptedSignature = encryptRSA(DS,serverPublicKey);
            //create stream to send to server
            DataOutputStream sendSignature = new DataOutputStream(sSign.getOutputStream());
            //write signature to stream
            sendSignature.writeUTF(DS);
            //Step 3 complete
            
            
            //retrieve and store the final response of client
            DataInputStream receiveResp = new DataInputStream(sResponse.getInputStream());
            String finalResp = receiveResp.readUTF();
            
            //switch on security
            btnSecure.setText("Secure : ON");
            btnSecure.setSelected(true);
            
            //hide allow Button
            btnAllowProtocol.setVisible(false);
            textAreaSecure.setText("Security is enabled");
            }catch(IOException e){} catch (Exception ex) {
                Logger.getLogger(ChatClient.class.getName()).log(Level.SEVERE, null, ex);
            }
    }//GEN-LAST:event_btnAllowProtocolActionPerformed

    private void ConnectionStatusTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ConnectionStatusTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_ConnectionStatusTextFieldActionPerformed
    private static KeyPair GenerateKeyPair() throws Exception{
        KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
        generator.initialize(2048,SecureRandom.getInstance("SHA1PRNG", "SUN"));
        return generator.generateKeyPair();
    }
    private static String RandomStringGenerator( int len ){
        StringBuilder sb = new StringBuilder( len );
        for( int i = 0; i < len; i++ ) 
            sb.append( charList.charAt( rnd.nextInt(charList.length()) ) );
        return sb.toString();
    }
    private static String encryptRSA(String msgEncrypt,PublicKey publicKey) throws Exception
    {
        Cipher encryptCipher = Cipher.getInstance("RSA");
        encryptCipher.init(Cipher.ENCRYPT_MODE,publicKey);
        byte[] cipherText = encryptCipher.doFinal(msgEncrypt.getBytes(UTF_8));
        return Base64.getEncoder().encodeToString(cipherText);
    }
    private static String decryptRSA(String msgCipher,PrivateKey privateKey) throws Exception
    {
        byte[] bytes = Base64.getDecoder().decode(msgCipher);
        Cipher decriptCipher = Cipher.getInstance("RSA");
        decriptCipher.init(Cipher.DECRYPT_MODE, privateKey);
        return new String(decriptCipher.doFinal(bytes),"UTF-8");
    }
    private static String signRSA(String msgSign,PrivateKey privateKey) throws Exception
    {
          
        Signature signed = Signature.getInstance("SHA1withRSA");
        signed.initSign(privateKey);
        signed.update(msgSign.getBytes("UTF-8"));
        byte[] signature = signed.sign();
        return Base64.getEncoder().encodeToString(signature);
    }
    private static boolean verifyRSA(String msgVerify,String signature,PublicKey publicKey) throws Exception
    {
          
        Signature publicSignature = Signature.getInstance("SHA1withRSA");
        publicSignature.initVerify(publicKey);
        publicSignature.update(msgVerify.getBytes("UTF-8"));
        byte[] signatureBytes = Base64.getDecoder().decode(signature);
        return publicSignature.verify(signatureBytes);  
    }
        private static String hash(String password) throws UnsupportedEncodingException
    {
        String sha1 = "";
        try
        {
            MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(password.getBytes("UTF-8"));
            sha1 = byteToHex(crypt.digest());
        }
        catch(NoSuchAlgorithmException | UnsupportedEncodingException e)
        {
            showMessageDialog(null, "No such algorithm or unsupported encoding");
        }
        return sha1;
    }

    private static String byteToHex(final byte[] hash)
    {
        Formatter formatter = new Formatter();
        for (byte b : hash)
        {
            formatter.format("%02x", b);
        }
        String result = formatter.toString();
        formatter.close();
        return result;
    }
    

    private static String encryptAES(String value) {
        try {
            byte[] raw = Base64.getDecoder().decode(keyAES.getBytes());
            SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            String encrypt = Base64.getEncoder().encodeToString(cipher.doFinal(value.getBytes()));
            return encrypt;
        } catch (NoSuchAlgorithmException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException | NoSuchPaddingException ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
   
    public static String decryptAES(String encrypted) {
        try {
            Key k = new SecretKeySpec(Base64.getDecoder().decode(keyAES), "AES");
            Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
            c.init(Cipher.DECRYPT_MODE, k);
            byte[] decodedValue = Base64.getDecoder().decode(encrypted);
            byte[] decValue = c.doFinal(decodedValue);
            String decryptedValue = new String(decValue);
            return decryptedValue;
        } catch (IllegalBlockSizeException | BadPaddingException | InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
   

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ChatServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new ChatServer().setVisible(true);
                } catch (Exception ex) {
                    Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
        
        String msg = "";
        try{
        ss = new ServerSocket(6032);
        s = ss.accept();
        mis = new DataInputStream(s.getInputStream());
        mos = new DataOutputStream(s.getOutputStream());
        
        ssFile = new ServerSocket(6033);
        sFile = ssFile.accept();
        
        ssPublic = new ServerSocket(6034);
        sPublic = ssPublic.accept();
        
        ssResponse = new ServerSocket(6035);
        sResponse = ssResponse.accept();
        
        ssChall = new ServerSocket(6036);
        sChall = ssChall.accept();
        
        ssSign = new ServerSocket(6037);
        sSign = ssSign.accept();
        
        ssEFile = new ServerSocket(6038);
        sEFile = ssEFile.accept();
        
        sDFile = new Socket("127.0.0.1",6039);

        
        dis2 = new DataInputStream(sEFile.getInputStream());
        dos2 = new DataOutputStream(sEFile.getOutputStream());
        
        connectionStatusIcon.setIcon(new ImageIcon("src\\chatserver\\connectionOK.png")); // NOI18N



        pair = GenerateKeyPair();
        //Create Challenge to send to Client
        serverChall = RandomStringGenerator(8);
        ObjectOutputStream publicKeySender = new ObjectOutputStream(sPublic.getOutputStream());
        publicKeySender.writeObject(pair.getPublic());
        publicKeySender.flush();
         //retrieve and assigns clients public key from socket stream.
                ObjectInputStream objectClientKey = new ObjectInputStream(sPublic.getInputStream());
                clientPublicKey = (PublicKey)objectClientKey.readObject();
        System.out.println(pair.getPublic());
        fis = new DataInputStream(sFile.getInputStream());
        fos = new DataOutputStream(sFile.getOutputStream());
        
        while(!msg.equals("exit"))
        {
            msg = mis.readUTF();
            if(msg.equals("Client Requested Secure Channel. Please click allow"))
            {
                    btnAllowProtocol.setVisible(true);
            }
            if(btnSelect==1)
            {
                System.out.println("The encrypted message received is : "+msg);
                msgArea.setText(msgArea.getText().trim()+"\n"+decryptAES(msg));
            }
            else
            {
                if(!keyAES.equals(""))
                        {
                            if(msg.equals(encryptAES(strSwitchOffSecure)))
                            {
                            }
                            else
                                msgArea.setText(msgArea.getText().trim()+"\n"+msg);
                        }
                        else
                            msgArea.setText(msgArea.getText().trim()+"\n"+msg);
            }
        }
        }catch(Exception e){
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, e);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField ConnectionStatusTextField;
    private static javax.swing.JToggleButton btnAllowProtocol;
    private javax.swing.JButton btnAttachFile;
    private javax.swing.JButton btnDownloadFile;
    private static javax.swing.JToggleButton btnSecure;
    private javax.swing.JButton btnSend;
    private javax.swing.JButton btnSendFile;
    private static javax.swing.JLabel connectionStatusIcon;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextArea jTextArea1;
    private static javax.swing.JTextArea msgArea;
    private javax.swing.JTextArea msgText;
    private javax.swing.JTextArea textAreaSecure;
    // End of variables declaration//GEN-END:variables
}
