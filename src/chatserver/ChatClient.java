/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package chatserver;

import java.awt.Image;
import java.awt.MediaTracker;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.ServerSocket;
import java.net.Socket;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.util.Arrays;
import java.util.Base64;
import java.util.Formatter;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import static javax.swing.JOptionPane.showMessageDialog;


public class ChatClient extends javax.swing.JFrame {

    static Socket s;
    static Socket sFile;
    static Socket sResponse;
    static Socket sPublic;
    static Socket sChall;
    static Socket sSign;
    static Socket sEFile;
    
    static ServerSocket ssDFile;
    static Socket sDFile;
    
    static DataInputStream dis1;
    static DataOutputStream dos1;
    static DataInputStream dis2;
    static DataOutputStream dos2;
    static DataInputStream fis;
    static DataOutputStream fos;
    
    static String strSwitchOffSecure = "Server Discontinues Security. Please disable security by clicking secure button";
    static String keyAES = "";
    static String fileName;
    static String serverChall;
    static String clientChall;
    static final String charList = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    
    static KeyPair pair;
    
    static File file;
    
    static PublicKey serverPublicKey;
    
    static int btnSelect;
    
    static SecureRandom rnd = new SecureRandom();
    
    public ChatClient() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        msgArea = new javax.swing.JTextArea();
        msgText = new javax.swing.JTextField();
        btnSend = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        textAreaSecure = new javax.swing.JTextArea();
        btnSendFile = new javax.swing.JButton();
        btnAttachFile = new javax.swing.JButton();
        btnDownloadFile = new javax.swing.JButton();
        btnSecure = new javax.swing.JToggleButton();
        connectionStatusIcon = new javax.swing.JLabel();
        ConnectionStatusTextField = new javax.swing.JTextField();
        btnAllowProtocol = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(255, 255, 255));

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));

        msgArea.setEditable(false);
        msgArea.setColumns(20);
        msgArea.setRows(5);
        jScrollPane1.setViewportView(msgArea);

        msgText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                msgTextActionPerformed(evt);
            }
        });

        btnSend.setText("Send");
        btnSend.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendActionPerformed(evt);
            }
        });

        textAreaSecure.setColumns(20);
        textAreaSecure.setLineWrap(true);
        textAreaSecure.setRows(5);
        textAreaSecure.setText("Security is disabled by default.");
        textAreaSecure.setWrapStyleWord(true);
        jScrollPane2.setViewportView(textAreaSecure);

        btnSendFile.setText("Send File");
        btnSendFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSendFileActionPerformed(evt);
            }
        });

        btnAttachFile.setText("Attach");
        btnAttachFile.setToolTipText("");
        btnAttachFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAttachFileActionPerformed(evt);
            }
        });

        btnDownloadFile.setText("Download File");
        btnDownloadFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownloadFileActionPerformed(evt);
            }
        });

        btnSecure.setText("Secure : NO");
        btnSecure.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSecureActionPerformed(evt);
            }
        });

        connectionStatusIcon.setBackground(new java.awt.Color(255, 255, 255));
        connectionStatusIcon.setIcon(new javax.swing.ImageIcon(getClass().getResource("/chatserver/noconnection.png"))); // NOI18N
        connectionStatusIcon.setToolTipText("");

        ConnectionStatusTextField.setEditable(false);
        ConnectionStatusTextField.setBackground(new java.awt.Color(255, 255, 255));
        ConnectionStatusTextField.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        ConnectionStatusTextField.setText("\"A\" Connection Status : ");
        ConnectionStatusTextField.setBorder(null);

        btnAllowProtocol.setText("Allow");
        btnAllowProtocol.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAllowProtocolActionPerformed(evt);
            }
        });

        jLabel1.setFont(jLabel1.getFont().deriveFont(jLabel1.getFont().getStyle() | java.awt.Font.BOLD, 30));
        jLabel1.setText("B");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(msgText)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 363, Short.MAX_VALUE))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 191, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(jPanel1Layout.createSequentialGroup()
                                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addGroup(jPanel1Layout.createSequentialGroup()
                                            .addComponent(btnAttachFile, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(18, 18, 18)
                                            .addComponent(btnSendFile, javax.swing.GroupLayout.PREFERRED_SIZE, 82, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addComponent(btnDownloadFile, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(jPanel1Layout.createSequentialGroup()
                                            .addComponent(btnSecure, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(btnAllowProtocol, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                                    .addGap(13, 13, 13)))
                            .addComponent(btnSend, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(64, 64, 64)
                        .addComponent(ConnectionStatusTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(connectionStatusIcon)
                        .addGap(6, 6, 6)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(17, 17, 17)
                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(ConnectionStatusTextField, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addComponent(connectionStatusIcon)
                        .addGap(7, 7, 7)))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 357, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(btnSecure, javax.swing.GroupLayout.DEFAULT_SIZE, 47, Short.MAX_VALUE)
                            .addComponent(btnAllowProtocol, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(11, 11, 11)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnAttachFile, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnSendFile, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(19, 19, 19)
                        .addComponent(btnDownloadFile, javax.swing.GroupLayout.DEFAULT_SIZE, 76, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED, 20, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(msgText, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnSend, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(21, 21, 21))
        );

        btnAllowProtocol.setVisible(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void msgTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_msgTextActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_msgTextActionPerformed

    private void btnSendActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendActionPerformed
        String msgOut = ""; 
        try{
            msgOut = msgText.getText().trim();
            dos1 = new DataOutputStream(s.getOutputStream());
            if(btnSelect==1)
            {
                System.out.println("the encypted message sent is :"+encryptAES("Client :"+msgOut));
                dos1.writeUTF(encryptAES("Client :"+msgOut));
            }
            else
                dos1.writeUTF("Client : "+msgOut);
                msgArea.setText(msgArea.getText().trim()+"\n"+"me :"+msgOut);
                msgText.setText("");
        }catch(Exception e)
        {
            System.out.println("error");
        }
    }//GEN-LAST:event_btnSendActionPerformed

    private void btnAttachFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAttachFileActionPerformed
        JFileChooser chooser = new JFileChooser();
        chooser.showOpenDialog(null);
        file = chooser.getSelectedFile();
        fileName=file.getName();
        btnAttachFile.setText(fileName);       
    }//GEN-LAST:event_btnAttachFileActionPerformed

    private void btnSendFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSendFileActionPerformed
        try {
            if(btnAttachFile.getText().equals("Attach"))
            {
                msgArea.setText(msgArea.getText().trim()+"\n Please attach a file to send");
                return;
            }
            else    
            {
                if(btnSecure.isSelected())
                {   sEFile = new Socket("127.0.0.1",6038);
                    dos1.writeUTF(encryptAES("File received and Click Download"));
                    int fileSize = (int) file.length();
                    byte[] fileByteArray = new byte[(int) file.length()];
                    DataOutputStream fos = new DataOutputStream(sEFile.getOutputStream());
                    fos.writeInt(fileSize);
                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
                    bis.read(fileByteArray, 0, fileByteArray.length);
                    byte[] raw = Base64.getDecoder().decode(keyAES.getBytes());
                    SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
            // make cipher with key
                    Cipher c = Cipher.getInstance("AES");//cipher is going to obtain the instance of the AES algorithm
                    c.init(Cipher.ENCRYPT_MODE, skeySpec);//initializes the cipher to DECRYPT_MODE with the key created            
            // The output stream os is made equal to the output stream of socket s4.
                    OutputStream os = sEFile.getOutputStream();
                    
                    CipherOutputStream cos = new CipherOutputStream(os, c);
            
            // writes bytes of size myBythArray.length (the size of the user specified file) 
            // from myBythArray starting at 0 to output stream os.
                    cos.write(fileByteArray, 0, fileByteArray.length);
                                        System.out.println("File Encrypted and sent");
                    cos.flush(); // forces any buffered output bytes to be written out.
                    cos.close();//close cipher output stream
                    msgArea.setText(msgArea.getText().trim()+"\n File Sent - FILENAME: " + file.getName());
                    btnAttachFile.setText("Attach");
                    
                    
                }
                else
                {
                    dos1.writeUTF("File Received. Click Download - FILENAME: " + file.getName());
                    int fileSize = (int) file.length();//Obtain the file length and assign it to file size
                    byte[] fileByteArray = new byte[(int) file.length()];//Initialise a byte array for file
                    fos.writeInt(fileSize);
                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));//Obtain the file through fileinputstream
                    bis.read(fileByteArray, 0, fileByteArray.length);//Read the file
                    OutputStream os = sFile.getOutputStream();
                    os.write(fileByteArray, 0, fileByteArray.length);//Write the file onto  output stream
                    msgArea.setText(msgArea.getText().trim()+"\n File Sent");
                    os.flush();
                    btnAttachFile.setText("Attach");
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }//GEN-LAST:event_btnSendFileActionPerformed

    private void btnDownloadFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownloadFileActionPerformed
        try{  
            if(btnSecure.isSelected())
            {
                sDFile = ssDFile.accept();
                JFileChooser chooser = new JFileChooser(); // create object of JFileChooser
                chooser.showSaveDialog(null); // choose save location
                file = chooser.getSelectedFile(); // assign the file equal to f
                DataInputStream fis = new DataInputStream(sDFile.getInputStream());

                int fileLength = fis.readInt(); // read length of incoming file

                //  Create a byte array myByteArray while setting it to the value of filesize
                byte[] myByteArray = new byte[fileLength];
                byte[] raw = Base64.getDecoder().decode(keyAES.getBytes());
                SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
                Cipher cipher = Cipher.getInstance("AES");//cipher is going to obtain the instance of the AES algorithm
                cipher.init(Cipher.DECRYPT_MODE, skeySpec);//initializes the cipher to DECRYPT_MODE with the key created                
                // Create file output stream fos to write to the file specified by f
                FileOutputStream fops = new FileOutputStream(file);

                //creates the Cipher output stream and passes the cipher and the
                //file output stream that writes the file specified by f through it
                CipherOutputStream cos = new CipherOutputStream(fops,cipher);

                // Reads bytes from the input stream din4 and stores them into buffer myByteArray

                byte[] buffer = new byte[8192]; // any size greater than 0 will work
                int count;
                DataInputStream fis2 = new DataInputStream(sDFile.getInputStream());
                while ((count = fis2.read(buffer)) > 0)
                {
                    cos.write(buffer, 0, count);
                }
                    System.out.println("File Decrypted and Downloaded");

                fops.flush();//forces any buffered output bytes to be written out
                cos.close();//closes the cipher outputStream
            }
            else
            {
                JFileChooser chooser = new JFileChooser();// create object of JFileChooser
                chooser.showSaveDialog(null);// choose save location
                file = chooser.getSelectedFile();// assign the file equal to file
                int fileSize = fis.readInt();//read the file size
                byte[] myByteArray = new byte[fileSize];//  Create a byte array myByteArray while setting it to the value of filesize
                //Create a input stream to read the incoming files
                fis.readFully(myByteArray);
                try ( //Create a output stream to write the file
                        FileOutputStream fileOS = new FileOutputStream(file)) {
                        fileOS.write(myByteArray);
                        fileOS.close();
            //close the filesoutput stream
                }
            }
        }catch(Exception e)
        {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, e);
        }
            
        
    }//GEN-LAST:event_btnDownloadFileActionPerformed

    private void btnSecureActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSecureActionPerformed
try {
            if(btnSecure.isSelected())
            {
                btnSelect=1;
                btnSecure.setText("Secure : ON");
                textAreaSecure.setText("Security is being enabled");
                
                
                //Step 1 of protocol
                
                //Part A of Step 1 - Send encrypted client challenge to server

                //encrypt the challenge with servers public key
                String encryptedClientChall = encryptRSA(clientChall,serverPublicKey);
                //create stream to send to server
                DataOutputStream sendClientChallenge = new DataOutputStream(sChall.getOutputStream());
                //write the encrypted server challenge to stream
                sendClientChallenge.writeUTF(encryptedClientChall);
                //part A complete
                
                //Part B of Step 1 - Send the digitally signed hash of client challenge encrypted with servers public key 
                //Create the hash of client challenge
                String I = hash(clientChall);
                //Digitally sign the client challenge with client's private key
                String DS = signRSA(I,pair.getPrivate());
                //Encrypt the Dgitally signed hashed challenge with clients public key
//                String encryptedServerSignature = encryptRSA(DS, clientPublicKey);
                //Create stream to send to server
                DataOutputStream sendSignature = new DataOutputStream(sSign.getOutputStream());
                //write the encrypted signature of the hashed challenge
                sendSignature.writeUTF(DS);
                //part B complete
                
                //Step 1 complete
                
                //Send a prompt to server to accept protocol connection
                DataOutputStream sendAcceptProtocol = new DataOutputStream(s.getOutputStream());
                sendAcceptProtocol.writeUTF("Client Requested Secure Channel. Please click allow");
                
                
                //Step 4 of Protocol
                
                //Retrieve and assign encrypted server challenge
                DataInputStream receiveServerChall = new DataInputStream(sChall.getInputStream());
                String encryptedServerChall = receiveServerChall.readUTF();
                //decrypt and assign encrypted server challenge
                serverChall = decryptRSA(encryptedServerChall,pair.getPrivate());
                
                
                //REMEMBER TO ADD RESPONSE CHECK FOR AES SESSION KEY
                
                
                //Retrieve and store the enrcypted Response from the server
                DataInputStream receiveResponse = new DataInputStream(sResponse.getInputStream());
                String encryptedServerResponse = receiveResponse.readUTF();
                //Decrypt and store the decrypted server response
                String serverResponse = decryptRSA(encryptedServerResponse,pair.getPrivate());
                //Retrieve and assign signature from stream
                DataInputStream receiveSignature = new DataInputStream(sSign.getInputStream());
                String encryptedSignature = receiveSignature.readUTF();
                //decrypt and assign encrypted signature
//                String decryptedSignature = decryptRSA(encryptedSignature,pair.getPrivate());
                //hash the server challenege and response
                String serverChallRespVerify = hash(serverChall+serverResponse);
                if(verifyRSA(serverChallRespVerify,encryptedSignature, serverPublicKey))
                {
                    String hash1 = hash(serverChall+clientChall);
                    byte[] test = hash1.getBytes(UTF_8);
                    byte[] test1 = Arrays.copyOfRange(test,0,16);
                    String key = Base64.getEncoder().encodeToString(test1);
                    keyAES = key;
                    String pw = "mypassword";
                    String encrypted = encryptAES(pw);
                      System.out.println("decrypted value:" + decryptAES(encrypted));
                      System.out.println("AES key : "+keyAES);
                }
                else
                    throw new Exception("Verification failed");
                //Step 4 Complete
                
                //Step 5 of protocol
                
                //Send response to server
                DataOutputStream sendClientResponse = new DataOutputStream(sResponse.getOutputStream());
                sendClientResponse.writeUTF(encryptAES(serverChall));
                
                
                System.out.println(keyAES);
            }
            else
            {
                btnSelect=0;
                DataOutputStream stopSecure = new DataOutputStream(s.getOutputStream());
                stopSecure.writeUTF(encryptAES(strSwitchOffSecure));
                btnSecure.setText("Secure : OFF");
                textAreaSecure.setText("Security has been disabled.");
            }
        } catch (Exception ex) {;
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }        
    }//GEN-LAST:event_btnSecureActionPerformed

    private void btnAllowProtocolActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAllowProtocolActionPerformed
        
        try{
            //Step 2 of Protocol initiated by Server
            btnSelect = 1;
            //Retreive and assign Server Challenge from stream
            DataInputStream receiveServerChallenge = new DataInputStream(sChall.getInputStream());
            String encryptedServerChall = receiveServerChallenge.readUTF();
            //Decrypt encrypted Server Challenge with client private key
            System.out.println("encrypted server challenge is:"+encryptedServerChall);
            serverChall = decryptRSA(encryptedServerChall,pair.getPrivate());
            System.out.println("server challenge : "+serverChall);

            //Retreive and assign signature from stream
            DataInputStream receiveServerSignature = new DataInputStream(sSign.getInputStream());
            String encryptedServerSignature = receiveServerSignature.readUTF();
            //Decrypt encrypted hashed server challenge signature with client private key
 //           String decryptedServerSignature = decryptRSA(encryptedServerSignature,pair.getPrivate());
            //hash the previously obtained plain server challenge
            String serverChallVerify = hash(serverChall);
            //Verify the signature using hashed plain server challenge
            if(verifyRSA(serverChallVerify,encryptedServerSignature,serverPublicKey))
            {
                String hash1 = hash(serverChall+clientChall);
                    byte[] test = hash1.getBytes(UTF_8);
                    byte[] test1 = Arrays.copyOfRange(test,0,16);
                    String key = Base64.getEncoder().encodeToString(test1);
                    keyAES = key;
//                byte[] key = (serverChall+clientChall).getBytes(UTF_8);
//                MessageDigest sha = MessageDigest.getInstance("SHA-1");
//                key = sha.digest(key);
//                                    System.out.println(key.length);
//
//                key = Arrays.copyOf(key, 16); // use only first 128 bit
//                keyAES = new SecretKeySpec(key, "AES");
//                System.out.println(Base64.getEncoder().encodeToString(keyAES.getEncoded()));
//                System.out.println(keyAES.getEncoded().length);
//                
//                                System.out.println("AES encryption of Hello World = "+encryptAES("Hello World"));
//                                System.out.println("AES decryption of Hello World = "+decryptAES("Hello World"));
//                
                //Verification Successful
                //Convert the hash of server and client challenge into byte array
                //byte[] decodedKey = Base64.getDecoder().decode(hash(serverChall+clientChall));
                //feed the byte array to SecretKeySpec object to create the AES session key 
                //creates a 128 bit session key by trimming the hash of server and client challenge.
                //keyAES = new SecretKeySpec(decodedKey,0,16,"AES");
            }
            else
                throw new Exception("Verification failed");
            //Step 2 complete
            
            //Step 3 begins
            
            //part a - Send encrypted client challenge
            //Encrypt client Challenge
            String encryptedClientChall = encryptRSA(clientChall,serverPublicKey);
            //create stream to send to server
            DataOutputStream sendClientChall = new DataOutputStream(sChall.getOutputStream());
            //write encrypted client challenge into stream
            sendClientChall.writeUTF(encryptedClientChall);
            System.out.println("the client chall is :"+clientChall);
            System.out.println("the encrypted client chall is"+encryptedClientChall);
            
            //part b - send server challenge encrypted first with session key and then with servers public key
            //encrypt with session key and assign server challenge
            String encryptedAESServerChall = encryptAES(serverChall);
            System.out.println("Sending the challenge to server");
            System.out.println("Sending the digitally sgned hashed challenge to server");
            System.out.println("step complete");
            
            System.out.println("session key : "+keyAES);
            
                      System.out.println("\n\n");
            //encrypt aes encrypted server challenge with the servers public key
            String encryptedResponse = encryptRSA(encryptedAESServerChall,serverPublicKey);
            //create stream to send to server
            DataOutputStream sendResponse = new DataOutputStream(sResponse.getOutputStream());
            //write the encrypted response to the stream
            sendResponse.writeUTF(encryptedResponse);
            //part c - send signed hash of challenge and response encrypted by server public key
            //Hash the challenge and response
            String I = hash(clientChall+encryptedAESServerChall);

            //sign the hash of challenge and response
            String DS = signRSA(I,pair.getPrivate());
            //encrypt the signature with servers public key
//            String encryptedSignature = encryptRSA(DS,serverPublicKey);
            //create stream to send to server
            DataOutputStream sendSignature = new DataOutputStream(sSign.getOutputStream());
            //write signature to stream
            sendSignature.writeUTF(DS);
            //Step 3 complete

            
            //retrieve and store the final response of serve
            DataInputStream receiveResp = new DataInputStream(sResponse.getInputStream());
            String finalResp = receiveResp.readUTF();
            
            //switch on security
            btnSecure.setText("Secure : ON");
            btnSecure.setSelected(true);
            
            //hide allow Button
            btnAllowProtocol.setVisible(false);
            textAreaSecure.setText("Security is enabled");
            }catch(IOException e){} catch (Exception ex) {
                Logger.getLogger(ChatClient.class.getName()).log(Level.SEVERE, null, ex);
            }
    }//GEN-LAST:event_btnAllowProtocolActionPerformed
    private static KeyPair generateKeyPair() throws Exception{
        KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
        generator.initialize(2048,new SecureRandom());
        return generator.generateKeyPair();
    }
    private static String RandomStringGenerator( int len ){
        StringBuilder sb = new StringBuilder( len );
        for( int i = 0; i < len; i++ ) 
            sb.append(charList.charAt(rnd.nextInt(charList.length()) ) );
        return sb.toString();
    }
    private static String encryptRSA(String msgEncrypt,PublicKey publicKey) throws Exception
    {
        Cipher encryptCipher = Cipher.getInstance("RSA");
        encryptCipher.init(Cipher.ENCRYPT_MODE,publicKey);
        byte[] cipherText = encryptCipher.doFinal(msgEncrypt.getBytes());
        return Base64.getEncoder().encodeToString(cipherText);
    }
    private static String decryptRSA(String msgCipher,PrivateKey privateKey) throws Exception
    {
        byte[] bytes = Base64.getDecoder().decode(msgCipher);
        Cipher decriptCipher = Cipher.getInstance("RSA");
        decriptCipher.init(Cipher.DECRYPT_MODE, privateKey);
        return new String(decriptCipher.doFinal(bytes));
    }
    private static String signRSA(String msgSign,PrivateKey privateKey) throws Exception
    {
        Signature signed = Signature.getInstance("SHA1withRSA");
        signed.initSign(privateKey);
        signed.update(msgSign.getBytes());
        byte[] signature = signed.sign();
        return Base64.getEncoder().encodeToString(signature);
    }
    private static boolean verifyRSA(String msgVerify,String signature,PublicKey publicKey) throws Exception
    {
        Signature publicSignature = Signature.getInstance("SHA1withRSA");
        publicSignature.initVerify(publicKey);
        publicSignature.update(msgVerify.getBytes());
        byte[] signatureBytes = Base64.getDecoder().decode(signature);
        return publicSignature.verify(signatureBytes);  
    }
     private static String hash(String password) throws UnsupportedEncodingException
    {
        String sha1 = "";
        try
        {
            MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(password.getBytes("UTF-8"));
            sha1 = byteToHex(crypt.digest());
        }
        catch(NoSuchAlgorithmException | UnsupportedEncodingException e)
        {
            showMessageDialog(null, "No such algorithm or unsupported encoding");
        }
        return sha1;
    }

    private static String byteToHex(final byte[] hash)
    {
        Formatter formatter = new Formatter();
        for (byte b : hash)
        {
            formatter.format("%02x", b);
        }
        String result = formatter.toString();
        formatter.close();
        return result;
    }
    
    private static String encryptAES(String value) throws NoSuchPaddingException {
        try {
            byte[] raw = Base64.getDecoder().decode(keyAES.getBytes());
            SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
            Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            String encrypt = Base64.getEncoder().encodeToString(cipher.doFinal(value.getBytes()));
            return encrypt;
        } catch (NoSuchAlgorithmException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException | NoSuchPaddingException ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
   
    public static String decryptAES(String encrypted) {
        try {
            Key k = new SecretKeySpec(Base64.getDecoder().decode(keyAES), "AES");
            Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
            c.init(Cipher.DECRYPT_MODE, k);
            byte[] decodedValue = Base64.getDecoder().decode(encrypted);
            byte[] decValue = c.doFinal(decodedValue);
            String decryptedValue = new String(decValue);
            return decryptedValue;
        } catch (IllegalBlockSizeException | BadPaddingException | InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException ex) {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ChatClient.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ChatClient.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ChatClient.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ChatClient.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ChatClient().setVisible(true);
            }
        });
        String msgIn = "";
        try{
        s = new Socket("127.0.0.1",6032);
        dis1 = new DataInputStream(s.getInputStream());
        dos1 = new DataOutputStream(s.getOutputStream());

        sFile = new Socket("127.0.0.1",6033);
        fis = new DataInputStream(sFile.getInputStream());
        fos = new DataOutputStream(sFile.getOutputStream());
        
        sPublic = new Socket("127.0.0.1",6034);
        
        sResponse = new Socket("127.0.0.1",6035);
        
        sChall = new Socket("127.0.0.1",6036);
        
        sSign = new Socket("127.0.0.1",6037);
        
        sEFile = new Socket("127.0.0.1",6038);
        
        
        ssDFile = new ServerSocket(6039);
        sDFile = ssDFile.accept();
        
        pair = generateKeyPair();
        //Create Challenge to send to Server
        clientChall = RandomStringGenerator(8);
        ObjectOutputStream publicKeySender = new ObjectOutputStream(sPublic.getOutputStream());
        publicKeySender.writeObject(pair.getPublic());
        publicKeySender.flush();
        //retrieve and assigns clients public key from socket stream.
                connectionStatusIcon.setIcon(new ImageIcon("src\\chatserver\\connectionOK.png")); // NOI18N

                    ObjectInputStream objectServerKey = new ObjectInputStream(sPublic.getInputStream());
                    serverPublicKey = (PublicKey)objectServerKey.readObject();
        System.out.println(pair.getPublic());
        while(!msgIn.equals("exit"))
        {   
                    msgIn = dis1.readUTF();
                    if(sEFile.isClosed())
                    {
                        sEFile = new Socket("127.0.0.1",6038);
                    }
                    if(msgIn.equals("Server Requested Secure Channel. Please click allow"))
                    {
                            btnAllowProtocol.setVisible(true);
                    }
                    if(btnSelect==1)
                    {
                        System.out.println("The encrypted message received is : "+msgIn);
                        msgArea.setText(msgArea.getText().trim()+"\n"+decryptAES(msgIn));
                    }
                    else
                    {
                        if(!keyAES.equals(""))
                        {
                            if(msgIn.equals(encryptAES(strSwitchOffSecure)))
                            {
                            }
                            else
                                msgArea.setText(msgArea.getText().trim()+"\n"+msgIn);
                        }
                        else
                            msgArea.setText(msgArea.getText().trim()+"\n"+msgIn);
                    }
        
        }
        }catch(Exception e)
        {
            Logger.getLogger(ChatServer.class.getName()).log(Level.SEVERE, null, e);
            showMessageDialog(null,"Error in client. Please restart client and server.");
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField ConnectionStatusTextField;
    private static javax.swing.JButton btnAllowProtocol;
    private javax.swing.JButton btnAttachFile;
    private javax.swing.JButton btnDownloadFile;
    private static javax.swing.JToggleButton btnSecure;
    private javax.swing.JButton btnSend;
    private javax.swing.JButton btnSendFile;
    private static javax.swing.JLabel connectionStatusIcon;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private static javax.swing.JTextArea msgArea;
    private javax.swing.JTextField msgText;
    private javax.swing.JTextArea textAreaSecure;
    // End of variables declaration//GEN-END:variables
}
